## Signal
### Signals - a limited form of IPC ( Interprocess communication )
There are three  types of signals:
- from hardware signal to POSIX signal（Portable Operating System Interface of UNIX）
  - segmentation fault -> SIGSEGV
- Generate directly from kernel
   - from exit() -> SIGCHLD
- Generated from one process to another 
    - "kill 1234" from another process 886

Hardware signal
-
- CPU is working on a program code, and PC points to user-space memory
- Hardware generates a hardware-interrupt that interrupts the execution of CPU

**Interrupt vectors are addresses placed by the OS, pointing to the codes inside kernel-space memory. Those codes are called interrupt handling routines.**
>  *IVT’s location is architecture-specific: maybe hardcoded in processor/designated space in the kernel-space
- Say, the keyboard is associated to a particular interrupt vector. Then the IHR will be invoked.

![enter image description here](https://lh3.googleusercontent.com/U-LRxCufNNjchw3bPQWMf5-WaJRODL7zyHyB6E79OGV__zc7w8Is3069IE9IJocXMBZ1eDEuodYS)

POSIX signals basics
-
### What is a POSIX signal?
- **Generated from CPU to kernel to processes** -- Processor Exceptions
   - Example: Segmentation fault. The signal is labeled as SIGSEGV, which comes from CPU to kernel then to process.
   -  Example: Floating point exception (e.g., divided by 0). The signal is labeled as SIGFPE, which comes from CPU to process
- **Generated from kernel to process**
   - Example: child process termination. The signal is labeled as SIGCHLD, which comes from the kernel to process.
- **Generate from one process to another**
    - from terminals , "Ctrl + C"
    - Using programs, "kill", "top"
    - Using the "kill()" system call 
  
### Process to Process: signal sending using "kill" program
The “kill” program is to send signals to target processes.
- The default signal sent by the kill program is SIGTERM.
- For each process, the default signal handler for SIGTERM is termination.
- Eventually, the target process looks like being terminated by kill.

**POSIX signals**
![enter image description here](https://lh3.googleusercontent.com/pK1Ekjl9g_1VAyi7rLAwwlbSMwo5FJs_v_r7lH--LWZ8RfXoQlBA3Gq_cNOvqbcX-HdntGzAqyg7)

### Signal: Synchronous vs. Asynchronous

**Asynchronous signal**: The signal received is NOT generated by the process itself.
- So, its arrival time is usually not deterministic from the process point of view.
- e.g., External hardware interrupt, another process sends Ctrl-C.

**Synchronous signal:** The signal is caused by the process itself.
- So, its arrival time is usually deterministic from the process point of view.
- E.g., A certain line leads to SIGFPE
- E.g., A certain line accesses an invalid memory region: SIGSEGV

 ### SIGTSTP & SIGCONT
```
	// "kill" is used to send signals
	kill -TSTP PIDx
	kill -CONT PIDx
```
The “terminal stop signal” suspends the process.
The “continuation signal” resumes the process. But, wait....
#### Foreground and background jobs
A characteristic of a **foreground job** in a shell is: The shell is waiting for the job to change state.
Foreground job:
- read input from stdin
- write output to stdout

![enter image description here](https://lh3.googleusercontent.com/WSEFGUuNdedXEKs0tiGrj1Kq3_58VIbWR0J2yLrWbqhcHuB6R5avND8p8LyS_UO_VlH_JR0G8Ifp)

### Sending signals in a process
The program **kill()** is not intended to kill anybody, but to send signals.
```
	int kill(pid_t pid, int sig)
	// pid: PID of the target process
	// sid: the desired signal. Using  "man 7 signal" for more details

	int main(void) 
	{
		int i, sum;
		srand(time(NULL));
		while(1) 
		{
			sum = 0;
			for(i = 0; i < 3; i++)
		        sum += (rand() % 6) + 1;
			if(sum == 18)
				kill(getpid(), SIGTERM);  //an alternative : raise(SIGTERM);
		}
		return 0;
	}
```

Handling POSIX signals
-
#### Registering new signal handlers
What is the meaning?
- The process no longer executes the default handler
- A signal is handled by a user-defined/given function
```
	signal( int signum, void (* function)(int) )
	
	// int signum : the signal number, e.g., SIGINT or SIGTERM
	// void (* function)(int) : A function pointer to the new handler.
```
**void (\* function)(int) : A function pointer to the new handler.**
This means your signal handler shall have:
- return type of "void"
- one argument with type int
- Two special values:
  - SIG_DFL :set to default handler
  - SIG_IGN :ignore the signal
```
	#include <signal.h>

	//define the customized signal handler
	void sig_handler(int sig) 
	{
		if(sig == SIGINT)
			printf(“\nCtrl + C\n”);
	}

	int main(void) 
	{
		signal(SIGINT, sig_handler); //register the signal handler for SIGINT
		printf(“Press enter\n“);
		getchar();
		printf(“End of program\n”);	
	}

$ ./os_lab 
Press enter
^C
 Ctrl + C 
^C
 Ctrl + C 
s
End of program

```
Apparently, when a signal handler returns, the process should go back to where it was executing.
But…this only happens when the involved system/library call can be resumed/restarted.
|can be resumed/restarted|cannot be resumed/restarted|
|--|--|
|[file related]open(), read(), write(); |sleep(); pause();|
|[process related] wait(), waitpid();|dozens of calls

#### How to implement “Signal” indeed?
- Signals are not implemented as a queue
- A bit array is used for indicating a signal has received or not.

|SIG|HUP|INT|QUIT|...|KILL|..
|--|--|--|--|--|--|--|
|BIT|0|0|1|...|0|...|

- the bit (or mask) is set to 1 once SIGx is received and the mask will be set to 0 once the signal is handled..
- 
####  Waiting for a signal
- The pause()system call suspends the calling process until a signal is received.
- wait() doesn’t mean “I wait”
	- wait() means “I wait for …”
	- It suspends only when it has a child process
```
	void sig_handler(int sig) {
	 }

	 int main(void) {
		 signal(SIGINT, sig_handler);
		 pause();
		 printf("Ctrl+C received. Bye!\n");
		 return 0;
	 }

// It suspends the execution of the program until a signal is caught Of course,
// pause() is designed not to be restarting after a signal handler.

```




